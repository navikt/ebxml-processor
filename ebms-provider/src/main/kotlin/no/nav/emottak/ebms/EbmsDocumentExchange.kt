/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package no.nav.emottak.ebms

import io.ktor.client.request.forms.MultiPartFormDataContent
import io.ktor.http.ContentType
import io.ktor.http.Headers
import io.ktor.http.HeadersBuilder
import io.ktor.http.HttpStatusCode
import io.ktor.http.content.PartData
import io.ktor.http.content.forEachPart
import io.ktor.server.application.ApplicationCall
import io.ktor.server.request.contentType
import io.ktor.server.request.header
import io.ktor.server.request.receive
import io.ktor.server.request.receiveMultipart
import io.ktor.server.response.respond
import io.ktor.server.response.respondText
import io.ktor.utils.io.ByteChannel
import io.ktor.utils.io.copyAndClose
import io.ktor.utils.io.toByteArray
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import no.nav.emottak.constants.SMTPHeaders
import no.nav.emottak.ebms.validation.MimeHeaders
import no.nav.emottak.ebms.validation.MimeValidationException
import no.nav.emottak.ebms.validation.validateMimeSoapEnvelope
import no.nav.emottak.message.model.DokumentType
import no.nav.emottak.message.model.EbMSDocument
import no.nav.emottak.message.model.EbmsAttachment
import no.nav.emottak.message.util.createUniqueMimeMessageId
import no.nav.emottak.message.xml.asByteArray
import no.nav.emottak.message.xml.asString
import no.nav.emottak.message.xml.getDocumentBuilder
import java.io.ByteArrayInputStream
import java.nio.charset.StandardCharsets
import java.util.Base64
import kotlin.uuid.ExperimentalUuidApi
import kotlin.uuid.Uuid

suspend fun PartData.payload(isBase64: Boolean = true): ByteArray {
    return when (this) {
        is PartData.FormItem -> if (isBase64) {
            try {
                Base64.getMimeDecoder().decode(this.value.trim())
            } catch (e: IllegalArgumentException) {
                log.warn("First characters in failing string: <${this.value.substring(0,50)}>", e)
                log.warn("Last characters in failing string: <${this.value.takeLast(50)}>", e)
                throw e
            }
        } else {
            this.value.toByteArray()
        }

        is PartData.FileItem -> {
            val byteReadChannel = this.provider()
            val byteWriteChannel = ByteChannel()
            byteReadChannel.copyAndClose(byteWriteChannel)
            if (isBase64) Base64.getMimeDecoder().decode(byteWriteChannel.toByteArray()) else byteWriteChannel.toByteArray()
        }
        else -> byteArrayOf()
    }
}
fun Headers.actuallyUsefulToString(): String {
    val sb = StringBuilder()
    entries().forEach {
        sb.append(it.key).append(":")
            .append("[${it.value.joinToString()}]\n")
    }
    return sb.toString()
}

@OptIn(ExperimentalUuidApi::class)
@Throws(MimeValidationException::class)
suspend fun ApplicationCall.receiveEbmsDokument(): EbMSDocument {
    log.info("Parsing message with Message-Id: ${request.header(SMTPHeaders.MESSAGE_ID)}")
    return when (val contentType = this.request.contentType().withoutParameters()) {
        ContentType.parse("multipart/related") -> {
            var start = contentType.parameter("start")
            lateinit var ebmsEnvelopeHeaders: Headers
            var ebmsEnvelope: Pair<String, ByteArray>? = null
            val attachments = mutableListOf<EbmsAttachment>()
            this@receiveEbmsDokument.receiveMultipart().forEachPart { partData ->
                if (start == null && ebmsEnvelope == null) start = partData.headers[MimeHeaders.CONTENT_ID]

                val isBase64 = "base64".equals(partData.headers[MimeHeaders.CONTENT_TRANSFER_ENCODING], true)
                if (partData.headers[MimeHeaders.CONTENT_ID] == start) {
                    ebmsEnvelopeHeaders = partData.headers
                    ebmsEnvelope = Pair(
                        partData.headers[MimeHeaders.CONTENT_ID]?.convertToValidatedContentID() ?: "GENERERT-${Uuid.random()}",
                        partData.payload(isBase64)
                    )
                } else {
                    attachments.add(
                        EbmsAttachment(
                            partData.payload(isBase64),
                            partData.contentType!!.contentType,
                            partData.headers[MimeHeaders.CONTENT_ID]!!.convertToValidatedContentID()
                        )
                    )
                }
                partData.dispose.invoke()
            }
            if (ebmsEnvelope == null) throw MimeValidationException("Failed to extract soap envelope from multipartdata")
            ebmsEnvelopeHeaders.validateMimeSoapEnvelope()
            EbMSDocument(
                ebmsEnvelope!!.first,
                withContext(Dispatchers.IO) {
                    getDocumentBuilder().parse(ByteArrayInputStream(ebmsEnvelope!!.second))
                },
                attachments
            )
        }

        ContentType.parse("text/xml") -> {
            val dokument = withContext(Dispatchers.IO) {
                if ("base64" == request.header(MimeHeaders.CONTENT_TRANSFER_ENCODING)?.lowercase()) {
                    Base64.getMimeDecoder().decode(this@receiveEbmsDokument.receive<ByteArray>())
                } else {
                    this@receiveEbmsDokument.receive<ByteArray>()
                }
            }
            EbMSDocument(
                this.request.headers[MimeHeaders.CONTENT_ID]!!.convertToValidatedContentID(),
                getDocumentBuilder().parse(ByteArrayInputStream(dokument)),
                emptyList()
            )
        }

        else -> {
            throw MimeValidationException("Ukjent request body med Content-Type $contentType")
        }
    }
}

private fun String.convertToValidatedContentID(): String {
    return Regex("""<(.*?)>""").find(this)?.groups?.get(1)?.value ?: this
}

suspend fun ApplicationCall.respondEbmsDokument(ebmsDokument: EbMSDocument) {
    if (ebmsDokument.dokumentType() == DokumentType.ACKNOWLEDGMENT) {
        log.info("Successfuly processed Payload Message")
    }

    this.response.headers.apply {
        this.append(MimeHeaders.SOAP_ACTION, "ebXML")
    }
    if (ebmsDokument.dokumentType() == DokumentType.PAYLOAD) {
        val ebxml = Base64.getMimeEncoder().encodeToString(ebmsDokument.dokument.asByteArray())
        val contentId = createUniqueMimeMessageId()
        val ebxmlFormItem = PartData.FormItem(
            ebxml,
            {},
            HeadersBuilder().apply {
                this.append(MimeHeaders.CONTENT_ID, "<$contentId>")
                this.append(MimeHeaders.CONTENT_TYPE, ContentType.Text.Xml.toString())
                this.append(MimeHeaders.CONTENT_TRANSFER_ENCODING, "base64")
            }.build()
        )
        val parts = mutableListOf<PartData>(ebxmlFormItem)
        ebmsDokument.attachments.first().let {
            PartData.FormItem(
                // Base64.getMimeEncoder().encodeToString(it.bytes), // Implicit ISO_8859_1
                String(Base64.getMimeEncoder().encode(it.bytes), StandardCharsets.UTF_8), // TODO verifiser
                {},
                HeadersBuilder().apply {
                    append(MimeHeaders.CONTENT_TRANSFER_ENCODING, "base64")
                    append(MimeHeaders.CONTENT_TYPE, it.contentType)
                    append(MimeHeaders.CONTENT_ID, "<${it.contentId}>")
                }.build()
            ).also {
                parts.add(it)
            }
        }
        this.response.headers.append(MimeHeaders.CONTENT_TRANSFER_ENCODING, "8bit")
        val boundary = "------=_Part" + System.currentTimeMillis() + "." + System.nanoTime()
        this.respond(
            HttpStatusCode.OK,
            MultiPartFormDataContent(
                parts,
                boundary,
                ContentType.parse("""multipart/related;boundary="$boundary";start="<$contentId>";type="text/xml"""")
            )
        )
    } else {
        this.response.headers.append(MimeHeaders.CONTENT_TYPE, ContentType.Text.Xml.toString())
        this.response.headers.append(MimeHeaders.CONTENT_TRANSFER_ENCODING, "8bit")
        this.respondText(status = HttpStatusCode.OK, text = ebmsDokument.dokument.asString())
    }
}
