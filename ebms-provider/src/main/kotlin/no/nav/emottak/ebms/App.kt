/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package no.nav.emottak.ebms

import io.ktor.http.*
import io.ktor.http.content.*
import io.ktor.server.application.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import no.nav.emottak.ebms.model.*
import no.nav.emottak.ebms.processing.flow.postEbmsMessageEndpoint
import no.nav.emottak.ebms.validation.MimeValidationException
import no.nav.emottak.ebms.validation.asParseAsSoapFault
import no.nav.emottak.ebms.validation.validateMime
import no.nav.emottak.ebms.validation.validateMimeAttachment
import no.nav.emottak.ebms.validation.validateMimeSoapEnvelope
import no.nav.emottak.ebms.xml.getDocumentBuilder
import no.nav.emottak.util.marker
import java.io.ByteArrayInputStream


fun main() {
    //val database = Database(mapHikariConfig(DatabaseConfig()))
    //database.migrate()
    embeddedServer(Netty, port = 8080, module = Application::myApplicationModule).start(wait = true)
}

fun PartData.payload() : ByteArray {
    return when(this) {
        is PartData.FormItem -> java.util.Base64.getMimeDecoder().decode(this.value)
        is PartData.FileItem -> {
            val bytes = this.streamProvider.invoke().readAllBytes()
            java.util.Base64.getMimeDecoder().decode(bytes)
        }
        else -> byteArrayOf()
    }
}

fun Application.myApplicationModule() {
    routing {

        get("/") {
            call.application.environment.log.info("TESTEST")
            call.respondText("Hello, world!")
        }
        postEbmsMessageEndpoint()
        post("/ebms") {
            // KRAV 5.5.2.1 validate MIME

            try {
                call.request.validateMime()
            } catch (it: MimeValidationException) {
                call.respond(HttpStatusCode.InternalServerError, it.asParseAsSoapFault())
                return@post

            }

            val ebMSDocument = when (val contentType = call.request.contentType().withoutParameters()) {
                ContentType.parse("multipart/related") -> {
                    val allParts = call.receiveMultipart().readAllParts()
                    try {
                        val dokument = allParts.find {
                            it.contentType?.withoutParameters() == ContentType.parse("text/xml") && it.contentDisposition == null
                        }.also { it?.validateMimeSoapEnvelope() ?: throw MimeValidationException("Unable to find soap envelope multipart") }!!.payload()
                        val attachments =
                            allParts.filter { it.contentDisposition?.disposition == ContentDisposition.Attachment.disposition }
                        attachments.forEach {
                            it.validateMimeAttachment()
                        }
                        EbMSDocument(
                            "",
                            getDocumentBuilder().parse(ByteArrayInputStream(dokument)),
                            attachments.map {
                                EbMSAttachment(
                                    it.payload(),
                                    it.contentType!!.contentType,
                                    it.headers["Content-Id"]!!
                                )
                            })
                    } catch (ex: MimeValidationException) {
                        call.respond(HttpStatusCode.InternalServerError, ex.asParseAsSoapFault())
                        return@post
                    }
                }
                ContentType.parse("text/xml") -> {
                    val dokument = call.receiveStream().readAllBytes()
                    EbMSDocument(
                        "",
                        getDocumentBuilder().parse(ByteArrayInputStream(dokument)),
                        emptyList()
                    )
                }
                else -> {
                    call.respond(HttpStatusCode.BadRequest, "Ukjent request body med Content-Type $contentType")
                    return@post
                }
            }

            val message = ebMSDocument.buildEbmMessage()
            try {
                //when (message) {
                //    is EbMSAcknowledgment -> message.process()
                //    is EbMSMessageError -> message.process()
                //    is EbMSPayloadMessage -> {
                //        when (val response = message.process()) {
                //            is EbMSAcknowledgment -> response.toEbmsDokument().sendResponse(response.messageHeader)
                //            is EbMSMessageError -> response.toEbmsDokument().sendErrorResponse(response.messageHeader)
                //        }
                //    }
                //}
            } catch (e: Exception) {
                call.application.environment.log.error(message.messageHeader.marker(), "Feil ved prosessering av melding", e)
                call.respond(HttpStatusCode.InternalServerError, "Feil ved prosessering av melding")
                return@post
            }

            //call payload processor
            println(ebMSDocument)

            call.respondText("Hello")
        }
    }

}
