/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package no.nav.emottak.ebms.async

import arrow.continuations.SuspendApp
import arrow.continuations.ktor.server
import arrow.core.raise.result
import arrow.fx.coroutines.resourceScope
import io.github.nomisRev.kafka.receiver.ReceiverRecord
import io.ktor.server.netty.Netty
import io.ktor.utils.io.CancellationException
import kotlinx.coroutines.awaitCancellation
import no.nav.emottak.ebms.CpaRepoClient
import no.nav.emottak.ebms.EBMS_PAYLOAD_SCOPE
import no.nav.emottak.ebms.EBMS_SEND_IN_SCOPE
import no.nav.emottak.ebms.EventManagerClient
import no.nav.emottak.ebms.PayloadProcessingClient
import no.nav.emottak.ebms.SendInClient
import no.nav.emottak.ebms.SmtpTransportClient
import no.nav.emottak.ebms.async.configuration.config
import no.nav.emottak.ebms.async.kafka.consumer.FailedMessageKafkaHandler
import no.nav.emottak.ebms.async.kafka.consumer.RETRY_COUNT_HEADER
import no.nav.emottak.ebms.async.kafka.producer.EbmsMessageProducer
import no.nav.emottak.ebms.async.persistence.Database
import no.nav.emottak.ebms.async.persistence.PayloadRepositoryTest.Companion.ebmsProviderDbContainer
import no.nav.emottak.ebms.async.persistence.repository.PayloadRepository
import no.nav.emottak.ebms.async.processing.MessageFilterService
import no.nav.emottak.ebms.async.processing.PayloadMessageForwardingService
import no.nav.emottak.ebms.async.processing.PayloadMessageService
import no.nav.emottak.ebms.async.processing.SignalMessageService
import no.nav.emottak.ebms.async.util.EventRegistrationServiceFake
import no.nav.emottak.ebms.defaultHttpClient
import no.nav.emottak.ebms.eventmanager.EventManagerService
import no.nav.emottak.ebms.processing.ProcessingService
import no.nav.emottak.ebms.scopedAuthHttpClient
import no.nav.emottak.ebms.sendin.SendInService
import no.nav.emottak.ebms.validation.CPAValidationService
import no.nav.emottak.message.model.AsyncPayload
import no.nav.emottak.message.model.MessagingCharacteristicsRequest
import no.nav.emottak.message.model.MessagingCharacteristicsResponse
import no.nav.emottak.message.model.PayloadProcessing
import no.nav.emottak.message.model.ProcessConfig
import no.nav.emottak.message.model.SignatureDetails
import no.nav.emottak.message.model.ValidationRequest
import no.nav.emottak.message.model.ValidationResult
import no.nav.emottak.utils.common.model.DuplicateCheckRequest
import no.nav.emottak.utils.common.model.DuplicateCheckResponse
import org.oasis_open.committees.ebxml_cppa.schema.cpp_cpa_2_0.PerMessageCharacteristicsType
import org.slf4j.LoggerFactory
import java.util.Timer
import kotlin.uuid.Uuid

val log = LoggerFactory.getLogger("no.nav.emottak.ebms.async.LocalApp")

fun main() = SuspendApp {
    /*
    This App is intended to run locally, using a Postgres DB and Kafka running in local containers (e.g. as started by RunLocalContainers).
    It is supposed to contain the same setup as the production App, with dummy services wherever needed for the current run/test.
    So far it has been used to test retry-logic, in this way:
    - start RunLocalContainers.main() in the IDE. Wait for local Kafka etc to be ready
    - start this App in the IDE. It should run according to its setup, using local DB and Kafka
    - run LocalTestClient.main() in the IDE, let it produce messages on local Kafka or whatever input you need for your test
     */

//    println(" ************ Setting up local database ")
//    val ebmsProviderDbContainer = ebmsPostgres()
//    ebmsProviderDbContainer.start()
//    val database = Database(ebmsProviderDbContainer.testConfiguration())
//    database.migrate(database.dataSource)

    // Use the config corresponding to Local containers
    val database = Database(getRunningPostgresConfiguration())
    println(" ************ Setting up to use local DB with URL: " + database.dataSource.jdbcUrl)

    val payloadRepository = PayloadRepository(database)

    // Use the config corresponding to Local containers
    val kafkaUrl = getRunningKafkaBrokerUrl()
    println(" ************ Setting up to use local Kafka with URL: " + kafkaUrl)
    System.setProperty("KAFKA_BROKERS", kafkaUrl)

    println(" ************ Setting up standard config ")
    System.setProperty("EBMS_RETRY_QUEUE", "true")
    System.setProperty("EBMS_PAYLOAD_RECEIVER", "true")
    System.setProperty("RETRY_PROCESS_INTERVAL_SECONDS", "60")
    System.setProperty("RETRY_INTERVALS_MINUTES", "2,2,3,3")
    val config = config()
    println(" ************ config.kafkaErrorQueue.active: " + config.kafkaErrorQueue.active)
    println(" ************ config.kafkaPayloadReceiver.active: " + config.kafkaPayloadReceiver.active)
    println(" ************ config.errorRetryPolicy.processIntervalSeconds: " + config.errorRetryPolicy.processIntervalSeconds)
    println(" ************ config.errorRetryPolicy.retriesPerInterval: " + config.errorRetryPolicy.retriesPerInterval)
    println(" ************ config.errorRetryPolicy.retryIntervalsMinutes: " + config.errorRetryPolicy.retryIntervalsMinutes)

    println(" ************ Setting up services ")
    val failedMessageQueue = FailedMessageKafkaHandler()

    val processingService = ProcessingService(
        httpClient = PayloadProcessingClient(scopedAuthHttpClient(EBMS_PAYLOAD_SCOPE))
    )
    val cpaValidationService = CPAValidationService(
        httpClient = DummyCpaRepoClient()
    )
    val sendInService = SendInService(
        httpClient = SendInClient(scopedAuthHttpClient(EBMS_SEND_IN_SCOPE))
    )

    val ebmsSignalProducer = EbmsMessageProducer(config.kafkaSignalProducer.topic, config.kafka)
    val ebmsPayloadProducer = EbmsMessageProducer(config.kafkaPayloadProducer.topic, config.kafka)

//    val smtpTransportClient = SmtpTransportClient(scopedAuthHttpClient(SMTP_TRANSPORT_SCOPE))
    val smtpTransportClient = DummySmtpTransportClient()

    val eventManagerService = EventManagerService(
//        EventManagerClient(scopedAuthHttpClient(EVENT_MANAGER_SCOPE))
        DummyEventManagerClient()
    )
//    val eventRegistrationService = EventRegistrationServiceImpl(
//        EventLoggingService(config().eventLogging, EventPublisherClient(config().kafka))
//    )
    val eventRegistrationService = EventRegistrationServiceFake()

    val payloadMessageForwardingService = PayloadMessageForwardingService(
        sendInService = sendInService,
        cpaValidationService = cpaValidationService,
        processingService = processingService,
        payloadRepository = payloadRepository,
        ebmsPayloadProducer = ebmsPayloadProducer,
        eventRegistrationService = eventRegistrationService
    )

    val payloadMessageService = PayloadMessageService(
        cpaValidationService = cpaValidationService,
        processingService = processingService,
        ebmsSignalProducer = ebmsSignalProducer,
        payloadMessageForwardingService = payloadMessageForwardingService,
        eventRegistrationService = eventRegistrationService,
        eventManagerService = eventManagerService,
        failedMessageQueue = failedMessageQueue
    )

    val signalMessageService = SignalMessageService(
        cpaValidationService = cpaValidationService,
        eventRegistrationService = eventRegistrationService
    )

    val messageFilterService = DummyMessageFilterService(
        payloadMessageService = payloadMessageService,
        signalMessageService = signalMessageService,
        smtpTransportClient = smtpTransportClient,
        eventRegistrationService = eventRegistrationService
    )

    val retryErrorsTimer = Timer("RetryErrorsTask", false)
    var pauseRetryErrorsTimerFlag = PauseRetryErrorsTimerFlag()

    println(" ************ Setting up Netty at 8080 ")

    result {
        resourceScope {
            launchSignalReceiver(
                config = config,
                messageFilterService = messageFilterService
            )
            launchPayloadReceiver(
                config = config,
                messageFilterService = messageFilterService
            )
            launchErrorRetryTask(
                config = config,
                retryErrorsTimer = retryErrorsTimer,
                messageFilterService = messageFilterService,
                failedMessageQueue = failedMessageQueue,
                pauseRetryErrorsTimerFlag = pauseRetryErrorsTimerFlag
            )

            server(
                Netty,
                port = 8080,
                module = {
                    ebmsProviderModule(
                        payloadRepository = payloadRepository,
                        messageFilterService = messageFilterService,
                        eventRegistrationService = eventRegistrationService,
                        failedMessageQueue = failedMessageQueue,
                        pauseRetryErrorsTimerFlag = pauseRetryErrorsTimerFlag
                    )
                }
            ).also { it.engineConfig.maxChunkSize = 100000 }

            awaitCancellation()
        }
    }
        .onFailure { error ->
            ebmsProviderDbContainer.stop()
            retryErrorsTimer.cancel()
            when (error) {
                is CancellationException -> {} // expected behaviour - normal shutdown
                else -> log.error("Unexpected shutdown initiated", error)
            }
        }

    println(" ************ All setup done ")
}

const val TESTMESSAGE_FAIL_HEADER = "numberOfTimesToFail"

// Dummy impl that accepts any message and simulates processing it OK, unless it has headers that define
// how many times it should simulate failure before it succeeds.
// In that case it will fail until the needed number of retries has been executed.
class DummyMessageFilterService(
    payloadMessageService: PayloadMessageService,
    signalMessageService: SignalMessageService,
    smtpTransportClient: DummySmtpTransportClient,
    eventRegistrationService: EventRegistrationServiceFake
) : MessageFilterService(
    payloadMessageService,
    signalMessageService,
    smtpTransportClient,
    eventRegistrationService
) {
    override suspend fun filterMessage(record: ReceiverRecord<String, ByteArray>) {
        println("--DUMMY Processing message with requestId: ${record.key()} and offset ${record.offset()}:\n" + record.value().decodeToString().substring(0, 100))
        val setFailing = record.headers().lastHeader(TESTMESSAGE_FAIL_HEADER)
        val retried = record.headers().lastHeader(RETRY_COUNT_HEADER)
        if (setFailing != null && retried != null) {
            val f = setFailing.value().decodeToString().toIntOrNull()
            val r = retried.value().decodeToString().toIntOrNull()
            if (f != null && r != null) {
                if (r <= f) {
                    println("--Set to fail again, number of times to fail: $f, number of retries now: $r")
                    payloadMessageService.failedMessageQueue.sendToRetry(
                        record = record,
                        reason = "Test message set to fail again"
                    )
                    return
                }
            }
        } else {
            println("--Retry/fail headers not found, not failing")
        }
        println("--Record simulated/processed OK")
    }
}

class DummyCpaRepoClient : CpaRepoClient(defaultHttpClient()) {
    override suspend fun postValidate(
        requestId: String,
        validationRequest: ValidationRequest
    ): ValidationResult {
        return ValidationResult(
            payloadProcessing = PayloadProcessing(
                SignatureDetails("cert".toByteArray(), "algo", "hash"),
                "dummy".toByteArray(),
                ProcessConfig(
                    false, false, false, false, false, false, false, false,
                    "dummy", "dummy"
                )
            )
        )
    }

    override suspend fun getMessagingCharacteristics(request: MessagingCharacteristicsRequest): MessagingCharacteristicsResponse {
        return MessagingCharacteristicsResponse(
            "dummyId",
            PerMessageCharacteristicsType.PER_MESSAGE,
            PerMessageCharacteristicsType.PER_MESSAGE,
            PerMessageCharacteristicsType.PER_MESSAGE
        )
    }
}

class DummyEventManagerClient : EventManagerClient(defaultHttpClient()) {
    override suspend fun duplicateCheck(duplicateCheckRequest: DuplicateCheckRequest): DuplicateCheckResponse {
        return DuplicateCheckResponse("dummyId", false)
    }
}

class DummySmtpTransportClient : SmtpTransportClient(defaultHttpClient()) {
    override suspend fun getPayload(referenceId: Uuid): List<AsyncPayload> {
        return listOf(AsyncPayload(referenceId, "contentId1", "text/plain", "Payload test content 1".toByteArray()))
    }
}
