/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package no.nav.emottak.ebms.async

import arrow.continuations.SuspendApp
import arrow.continuations.ktor.server
import arrow.core.raise.result
import arrow.fx.coroutines.resourceScope
import io.github.nomisRev.kafka.receiver.ReceiverRecord
import io.ktor.server.netty.Netty
import io.ktor.utils.io.CancellationException
import io.mockk.Runs
import io.mockk.every
import io.mockk.just
import io.mockk.mockkObject
import kotlinx.coroutines.awaitCancellation
import no.nav.emottak.ebms.CpaRepoClient
import no.nav.emottak.ebms.EventManagerClient
import no.nav.emottak.ebms.PayloadProcessingClient
import no.nav.emottak.ebms.SendInClient
import no.nav.emottak.ebms.SmtpTransportClient
import no.nav.emottak.ebms.async.configuration.config
import no.nav.emottak.ebms.async.kafka.consumer.FailedMessageKafkaHandler
import no.nav.emottak.ebms.async.kafka.consumer.RETRY_COUNT_HEADER
import no.nav.emottak.ebms.async.kafka.producer.EbmsMessageProducer
import no.nav.emottak.ebms.async.persistence.Database
import no.nav.emottak.ebms.async.persistence.PayloadRepositoryTest.Companion.ebmsProviderDbContainer
import no.nav.emottak.ebms.async.persistence.repository.MessagePendingAckRepository
import no.nav.emottak.ebms.async.persistence.repository.MessageReceivedRepository
import no.nav.emottak.ebms.async.persistence.repository.PayloadRepository
import no.nav.emottak.ebms.async.processing.MessageFilterService
import no.nav.emottak.ebms.async.processing.PayloadMessageForwardingService
import no.nav.emottak.ebms.async.processing.PayloadMessageService
import no.nav.emottak.ebms.async.processing.SignalMessageService
import no.nav.emottak.ebms.async.util.EventRegistrationServiceFake
import no.nav.emottak.ebms.defaultHttpClient
import no.nav.emottak.ebms.processing.ProcessingService
import no.nav.emottak.ebms.sendin.SendInService
import no.nav.emottak.ebms.validation.CPAValidationService
import no.nav.emottak.ebms.xml.ebmsSigning
import no.nav.emottak.message.model.AsyncPayload
import no.nav.emottak.message.model.EbmsMessage
import no.nav.emottak.message.model.MessagingCharacteristicsRequest
import no.nav.emottak.message.model.MessagingCharacteristicsResponse
import no.nav.emottak.message.model.PayloadProcessing
import no.nav.emottak.message.model.PayloadRequest
import no.nav.emottak.message.model.PayloadResponse
import no.nav.emottak.message.model.ProcessConfig
import no.nav.emottak.message.model.SignatureDetails
import no.nav.emottak.message.model.ValidationRequest
import no.nav.emottak.message.model.ValidationResult
import no.nav.emottak.utils.common.model.Addressing
import no.nav.emottak.utils.common.model.DuplicateCheckRequest
import no.nav.emottak.utils.common.model.DuplicateCheckResponse
import no.nav.emottak.utils.common.model.SendInRequest
import no.nav.emottak.utils.common.model.SendInResponse
import org.oasis_open.committees.ebxml_cppa.schema.cpp_cpa_2_0.PerMessageCharacteristicsType
import org.slf4j.LoggerFactory
import java.io.InputStream
import kotlin.uuid.Uuid

val log = LoggerFactory.getLogger("no.nav.emottak.ebms.async.LocalApp")

fun main() = SuspendApp {
    /*
    This App is intended to run locally, using a Postgres DB and Kafka running in local containers (e.g. as started by RunLocalContainers).
    It is supposed to contain the same setup as the production App, with dummy services wherever needed for the current run/test.
    It has been used to test retry-logic, in this way:
    - start RunLocalContainers.main() in the IDE. Wait for local Kafka etc to be ready
    - start this App in the IDE. It should run according to its setup, using local DB and Kafka
    - run LocalTestClient.main() in the IDE, let it produce messages on local Kafka or whatever input you need for your test
     */

    // Use the config corresponding to Local containers
    val database = Database(getRunningPostgresConfiguration())
    println(" ************ Setting up to use local DB with URL: " + database.dataSource.jdbcUrl)

    val payloadRepository = PayloadRepository(database)
    val messageReceivedRepository = MessageReceivedRepository(database)

    val kafkaUrl = getRunningKafkaBrokerUrl()
    println(" ************ Setting up to use local Kafka with URL: " + kafkaUrl)
    System.setProperty("KAFKA_BROKERS", kafkaUrl)

    println(" ************ Setting up standard config ")
    System.setProperty("EBMS_RETRY_QUEUE", "true")
    System.setProperty("EBMS_PAYLOAD_RECEIVER", "true")
    System.setProperty("EBMS_SIGNAL_PRODUCER", "true")
    // NOTE: payload production is always done, regardless of setting !!
    // Set up scheduled processes to run more often than default, so testing is faster
    System.setProperty("RETRY_PROCESS_INTERVAL", "1m")
    System.setProperty("RETRY_INTERVALS", "2m,2m,3m,3m")
    System.setProperty("RESEND_PROCESS_INTERVAL", "1m")
    System.setProperty("RESEND_INTERVAL", "2m")
    val config = config()
    println(" ************ config.kafkaErrorQueue.active: " + config.kafkaErrorQueue.active)
    println(" ************ config.kafkaPayloadReceiver.active: " + config.kafkaPayloadReceiver.active)
    println(" ************ config.errorRetryPolicy.processInterval: " + config.errorRetryPolicy.processInterval)
    println(" ************ config.errorRetryPolicy.retriesPerInterval: " + config.errorRetryPolicy.retriesPerInterval)
    println(" ************ config.errorRetryPolicy.retryIntervals: " + config.errorRetryPolicy.retryIntervals)
    println(" ************ config.messageResendPolicy.processInterval: " + config.messageResendPolicy.processInterval)
    println(" ************ config.messageResendPolicy.resendInterval: " + config.messageResendPolicy.resendInterval)

    println(" ************ Setting up services ")
    val failedMessageQueue = FailedMessageKafkaHandler()

    val messagePendingAckRepository = MessagePendingAckRepository(database, config.messageResendPolicy.resendInterval, config.messageResendPolicy.maxResends)

    // ebmsSigning er en Singleton brukt til å signere. Vi bare returnerer input-dokumentet, dvs det vil bli lagret/sendt uten signatur
    mockkObject(ebmsSigning)
    every { ebmsSigning.sign(any(), any()) } just Runs

    // Se dummy-implementasjoner lenger ned, kan tunes til ønsket oppførsel
    val processingService = ProcessingService(
        httpClient = DummyPayloadProcessingClient()
    )
    val cpaValidationService = CPAValidationServiceWithoutSignatureValidation(
        httpClient = DummyCpaRepoClient()
    )
    val sendInService = SendInService(
        httpClient = DummySendInClient()
    )
    val smtpTransportClient = DummySmtpTransportClient()

    val eventRegistrationService = EventRegistrationServiceFake()

    val ebmsSignalProducer = EbmsMessageProducer(config.kafkaSignalProducer.topic, config.kafka)
    val ebmsPayloadProducer = EbmsMessageProducer(config.kafkaPayloadProducer.topic, config.kafka)

    val payloadMessageForwardingService = PayloadMessageForwardingService(
        sendInService = sendInService,
        cpaValidationService = cpaValidationService,
        processingService = processingService,
        payloadRepository = payloadRepository,
        ebmsPayloadProducer = ebmsPayloadProducer,
        eventRegistrationService = eventRegistrationService,
        messagePendingAckRepository = messagePendingAckRepository
    )

    val payloadMessageService = PayloadMessageService(
        cpaValidationService = cpaValidationService,
        processingService = processingService,
        ebmsSignalProducer = ebmsSignalProducer,
        payloadMessageForwardingService = payloadMessageForwardingService,
        eventRegistrationService = eventRegistrationService,
        messageReceivedRepository = messageReceivedRepository,
        failedMessageQueue = failedMessageQueue
    )

    val signalMessageService = SignalMessageService(
        cpaValidationService = cpaValidationService,
        eventRegistrationService = eventRegistrationService,
        messagePendingAckRepository = messagePendingAckRepository
    )

    val messageFilterService = MessageFilterService(
        payloadMessageService = payloadMessageService,
        signalMessageService = signalMessageService,
        smtpTransportClient = smtpTransportClient,
        eventRegistrationService = eventRegistrationService
    )

    var pauseRetryErrorsTimerFlag = PauseRetryErrorsTimerFlag()

    println(" ************ Setting up Netty at 8080 ")

    result {
        resourceScope {
            launchSignalReceiver(
                config = config,
                messageFilterService = messageFilterService
            )
            launchPayloadReceiver(
                config = config,
                messageFilterService = messageFilterService
            )
            launchErrorRetryTask(
                config = config,
                messageFilterService = messageFilterService,
                failedMessageQueue = failedMessageQueue,
                pauseRetryErrorsTimerFlag = pauseRetryErrorsTimerFlag
            )
            launchMesssageResendTask(
                config = config,
                messagePendingAckRepository = messagePendingAckRepository,
                payloadMessageForwardingService = payloadMessageForwardingService
            )

            server(
                Netty,
                port = 8080,
                module = {
                    ebmsProviderModule(
                        payloadRepository = payloadRepository,
                        messageFilterService = messageFilterService,
                        eventRegistrationService = eventRegistrationService,
                        failedMessageQueue = failedMessageQueue,
                        pauseRetryErrorsTimerFlag = pauseRetryErrorsTimerFlag
                    )
                }
            ).also { it.engineConfig.maxChunkSize = 100000 }

            awaitCancellation()
        }
    }
        .onFailure { error ->
            ebmsProviderDbContainer.stop()
            when (error) {
                is CancellationException -> {} // expected behaviour - normal shutdown
                else -> log.error("Unexpected shutdown initiated", error)
            }
        }

    println(" ************ All setup done ")
}

class CPAValidationServiceWithoutSignatureValidation(
    httpClient: CpaRepoClient
) : CPAValidationService(httpClient) {
    override fun validateResult(
        validationResult: ValidationResult,
        message: EbmsMessage,
        checkSignature: Boolean
    ): ValidationResult {
        return super.validateResult(validationResult, message, false)
    }
}

// Dummy impl that accepts any message and simulates processing it OK, unless it has headers that define
// how many times it should simulate failure before it succeeds.
// In that case it will fail until the needed number of retries has been executed.
const val TESTMESSAGE_FAIL_HEADER = "numberOfTimesToFail"
class DummyMessageFilterService(
    payloadMessageService: PayloadMessageService,
    signalMessageService: SignalMessageService,
    smtpTransportClient: DummySmtpTransportClient,
    eventRegistrationService: EventRegistrationServiceFake
) : MessageFilterService(
    payloadMessageService,
    signalMessageService,
    smtpTransportClient,
    eventRegistrationService
) {
    override suspend fun filterMessage(record: ReceiverRecord<String, ByteArray>) {
        println("--DUMMY Processing message with requestId: ${record.key()} and offset ${record.offset()}:\n" + record.value().decodeToString().substring(0, 100))
        val setFailing = record.headers().lastHeader(TESTMESSAGE_FAIL_HEADER)
        val retried = record.headers().lastHeader(RETRY_COUNT_HEADER)
        if (setFailing != null && retried != null) {
            val f = setFailing.value().decodeToString().toIntOrNull()
            val r = retried.value().decodeToString().toIntOrNull()
            if (f != null && r != null) {
                if (r <= f) {
                    println("--Set to fail again, number of times to fail: $f, number of retries now: $r")
                    payloadMessageService.failedMessageQueue.sendToRetry(
                        record = record,
                        reason = "Test message set to fail again"
                    )
                    return
                }
            }
        } else {
            println("--Retry/fail headers not found, not failing")
        }
        println("--Record simulated/processed OK")
    }
}

// Dummy CPA repo that returns processing flags with everything turned off
class DummyCpaRepoClient : CpaRepoClient(defaultHttpClient()) {
    override suspend fun postValidate(
        requestId: String,
        validationRequest: ValidationRequest
    ): ValidationResult {
        return ValidationResult(
            payloadProcessing = PayloadProcessing(
                SignatureDetails("cert".toByteArray(), "algo", "hash"),
                "dummy".toByteArray(),
                ProcessConfig(
                    false, false, false, false, false, false, false, false,
                    "dummy", "dummy"
                )
            )
        )
    }

    override suspend fun getMessagingCharacteristics(request: MessagingCharacteristicsRequest): MessagingCharacteristicsResponse {
        return MessagingCharacteristicsResponse(
            "dummyId",
            PerMessageCharacteristicsType.PER_MESSAGE,
            PerMessageCharacteristicsType.PER_MESSAGE,
            PerMessageCharacteristicsType.PER_MESSAGE
        )
    }
}

// Dummy payload processing that just passes the input payload through
class DummyPayloadProcessingClient() : PayloadProcessingClient(defaultHttpClient()) {
    override suspend fun postPayloadRequest(payloadRequest: PayloadRequest): PayloadResponse {
        println("DummyPayloadProcessingClient: postPayloadRequest called with payloadRequest: $payloadRequest")
        return PayloadResponse(payloadRequest.payload)
    }
}

// Dummy Sendin processing that builds a hard coded with reversed from/to addresses from the request
class DummySendInClient() : SendInClient(defaultHttpClient()) {
    override suspend fun postSendIn(sendInRequest: SendInRequest): SendInResponse {
        println("DummySendInClient: postSendIn called with sendInRequest: $sendInRequest")
        var responsePayload = readClasspathFile("xml/harBorgerEgenandelFritakResponseFagmelding.xml")
        if (responsePayload == null) responsePayload = ""
        val responseMessageId = "22a46f21-33c6-4324-8e46-b704a59b5658"
        val responseConversationId = "17eb03e-9e43-43fb-874c-1fde9a28c308"
        val responseRequestId = "11111111-2222-3333-4444-555555555555"
        val service = "Inntektsforesporsel"
        val action = "InntektInformasjon"
        val addressing = Addressing(sendInRequest.addressing.from, sendInRequest.addressing.to, service, action)
        return SendInResponse(responseMessageId, responseConversationId, addressing, responsePayload.toByteArray(), responseRequestId)
    }
}

// Dummy duplcate check always returning FALSE
class DummyEventManagerClient : EventManagerClient(defaultHttpClient()) {
    override suspend fun duplicateCheck(duplicateCheckRequest: DuplicateCheckRequest): DuplicateCheckResponse {
        println("DummyEventManagerClient: duplicateCheck called with duplicateCheckRequest: $duplicateCheckRequest")
        return DuplicateCheckResponse("dummyId", false)
    }
}

// Dummy SMTP transport client that always returns a hard coded payload
class DummySmtpTransportClient : SmtpTransportClient(defaultHttpClient()) {
    override suspend fun getPayload(referenceId: Uuid): List<AsyncPayload> {
        println("DummySmtpTransportClient: getPayload called with referenceId: $referenceId")
        return listOf(AsyncPayload(referenceId, "contentId1", "text/plain", "Payload test content 1".toByteArray()))
    }
}

fun readClasspathFile(fileName: String): String? {
    val inputStream: InputStream? = DummySendInClient::class.java.getResourceAsStream("/$fileName")
    return inputStream?.bufferedReader(Charsets.UTF_8)?.use { it.readText() }
}
