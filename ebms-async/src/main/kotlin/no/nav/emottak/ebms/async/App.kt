/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package no.nav.emottak.ebms.async

import arrow.continuations.SuspendApp
import arrow.continuations.ktor.server
import arrow.core.raise.result
import arrow.fx.coroutines.resourceScope
import io.ktor.http.HttpStatusCode
import io.ktor.server.application.Application
import io.ktor.server.auth.authenticate
import io.ktor.server.netty.Netty
import io.ktor.server.response.respond
import io.ktor.server.response.respondText
import io.ktor.server.routing.Route
import io.ktor.server.routing.Routing
import io.ktor.server.routing.get
import io.ktor.server.routing.routing
import io.ktor.utils.io.CancellationException
import io.micrometer.prometheusmetrics.PrometheusConfig
import io.micrometer.prometheusmetrics.PrometheusMeterRegistry
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.awaitCancellation
import kotlinx.coroutines.launch
import no.nav.emottak.ebms.AZURE_AD_AUTH
import no.nav.emottak.ebms.CpaRepoClient
import no.nav.emottak.ebms.EBMS_PAYLOAD_SCOPE
import no.nav.emottak.ebms.EBMS_SEND_IN_SCOPE
import no.nav.emottak.ebms.EVENT_MANAGER_SCOPE
import no.nav.emottak.ebms.EventManagerClient
import no.nav.emottak.ebms.PayloadProcessingClient
import no.nav.emottak.ebms.SMTP_TRANSPORT_SCOPE
import no.nav.emottak.ebms.SendInClient
import no.nav.emottak.ebms.SmtpTransportClient
import no.nav.emottak.ebms.StatusResponse
import no.nav.emottak.ebms.async.configuration.Config
import no.nav.emottak.ebms.async.configuration.config
import no.nav.emottak.ebms.async.kafka.consumer.FailedMessageKafkaHandler
import no.nav.emottak.ebms.async.kafka.consumer.getRecord
import no.nav.emottak.ebms.async.kafka.consumer.startEbmsOutPayloadReceiver
import no.nav.emottak.ebms.async.kafka.consumer.startPayloadReceiver
import no.nav.emottak.ebms.async.kafka.consumer.startSignalReceiver
import no.nav.emottak.ebms.async.kafka.producer.EbmsMessageProducer
import no.nav.emottak.ebms.async.persistence.Database
import no.nav.emottak.ebms.async.persistence.ebmsDbConfig
import no.nav.emottak.ebms.async.persistence.ebmsMigrationConfig
import no.nav.emottak.ebms.async.persistence.repository.PayloadRepository
import no.nav.emottak.ebms.async.processing.MessageFilterService
import no.nav.emottak.ebms.async.processing.PayloadMessageForwardingService
import no.nav.emottak.ebms.async.processing.PayloadMessageService
import no.nav.emottak.ebms.async.processing.SignalMessageService
import no.nav.emottak.ebms.async.util.EventRegistrationService
import no.nav.emottak.ebms.async.util.EventRegistrationServiceImpl
import no.nav.emottak.ebms.defaultHttpClient
import no.nav.emottak.ebms.eventmanager.EventManagerService
import no.nav.emottak.ebms.processing.ProcessingService
import no.nav.emottak.ebms.registerHealthEndpoints
import no.nav.emottak.ebms.registerNavCheckStatus
import no.nav.emottak.ebms.registerPrometheusEndpoint
import no.nav.emottak.ebms.registerRootEndpoint
import no.nav.emottak.ebms.scopedAuthHttpClient
import no.nav.emottak.ebms.sendin.SendInService
import no.nav.emottak.ebms.validation.CPAValidationService
import no.nav.emottak.utils.environment.isProdEnv
import no.nav.emottak.utils.kafka.client.EventPublisherClient
import no.nav.emottak.utils.kafka.service.EventLoggingService
import org.slf4j.LoggerFactory
import java.util.Timer
import java.util.concurrent.TimeUnit
import kotlin.concurrent.scheduleAtFixedRate

val log = LoggerFactory.getLogger("no.nav.emottak.ebms.async.App")

fun main() = SuspendApp {
    val database = Database(ebmsDbConfig.value)
    database.migrate(ebmsMigrationConfig.value)
    val payloadRepository = PayloadRepository(database)

    val config = config()

    val failedMessageQueue = FailedMessageKafkaHandler()

    val processingService = ProcessingService(
        httpClient = PayloadProcessingClient(scopedAuthHttpClient(EBMS_PAYLOAD_SCOPE))
    )
    val cpaValidationService = CPAValidationService(
        httpClient = CpaRepoClient(defaultHttpClient())
    )
    val sendInService = SendInService(
        httpClient = SendInClient(scopedAuthHttpClient(EBMS_SEND_IN_SCOPE))
    )

    val ebmsSignalProducer = EbmsMessageProducer(config.kafkaSignalProducer.topic, config.kafka)
    val ebmsPayloadProducer = EbmsMessageProducer(config.kafkaPayloadProducer.topic, config.kafka)
    val ebmsInPayloadProducer = EbmsMessageProducer(config.kafkaEbmsInPayloadProducer.topic, config.kafka)

    val smtpTransportClient = SmtpTransportClient(scopedAuthHttpClient(SMTP_TRANSPORT_SCOPE))

    val eventManagerService = EventManagerService(
        EventManagerClient(scopedAuthHttpClient(EVENT_MANAGER_SCOPE))
    )
    val eventRegistrationService = EventRegistrationServiceImpl(
        EventLoggingService(config().eventLogging, EventPublisherClient(config().kafka))
    )

    val payloadMessageForwardingService = PayloadMessageForwardingService(
        sendInService = sendInService,
        cpaValidationService = cpaValidationService,
        processingService = processingService,
        payloadRepository = payloadRepository,
        ebmsPayloadProducer = ebmsPayloadProducer,
        ebmsInPayloadProducer = ebmsInPayloadProducer,
        eventRegistrationService = eventRegistrationService
    )

    val payloadMessageService = PayloadMessageService(
        cpaValidationService = cpaValidationService,
        processingService = processingService,
        ebmsSignalProducer = ebmsSignalProducer,
        payloadMessageForwardingService = payloadMessageForwardingService,
        eventRegistrationService = eventRegistrationService,
        eventManagerService = eventManagerService,
        failedMessageQueue = failedMessageQueue
    )

    val signalMessageService = SignalMessageService(
        cpaValidationService = cpaValidationService,
        eventRegistrationService = eventRegistrationService
    )

    val messageFilterService = MessageFilterService(
        payloadMessageService = payloadMessageService,
        signalMessageService = signalMessageService,
        smtpTransportClient = smtpTransportClient,
        eventRegistrationService = eventRegistrationService
    )

    val retryErrorsTimer = Timer("RetryErrorsTask", false)
    val pauseRetryErrorsTimerFlag = PauseRetryErrorsTimerFlag()

    result {
        resourceScope {
            launchSignalReceiver(
                config = config,
                messageFilterService = messageFilterService
            )
            launchPayloadReceiver(
                config = config,
                messageFilterService = messageFilterService
            )
            launchEbmsOutPayloadReceiver(
                config = config,
                payloadMessageForwardingService = payloadMessageForwardingService
            )
            launchErrorRetryTask(
                config = config,
                retryErrorsTimer = retryErrorsTimer,
                messageFilterService = messageFilterService,
                failedMessageQueue = failedMessageQueue,
                pauseRetryErrorsTimerFlag = pauseRetryErrorsTimerFlag
            )

            server(
                Netty,
                port = 8080,
                module = {
                    ebmsProviderModule(
                        payloadRepository = payloadRepository,
                        messageFilterService = messageFilterService,
                        eventRegistrationService = eventRegistrationService,
                        failedMessageQueue = failedMessageQueue,
                        pauseRetryErrorsTimerFlag = pauseRetryErrorsTimerFlag
                    )
                }
            ).also { it.engineConfig.maxChunkSize = 100000 }

            awaitCancellation()
        }
    }
        .onFailure { error ->
            when (error) {
                is CancellationException -> {} // expected behaviour - normal shutdown
                else -> log.error("Unexpected shutdown initiated", error)
            }
        }
}

class PauseRetryErrorsTimerFlag {
    var paused = false
}

fun CoroutineScope.launchPayloadReceiver(
    config: Config,
    messageFilterService: MessageFilterService
) {
    if (config.kafkaPayloadReceiver.active) {
        launch(Dispatchers.IO) {
            startPayloadReceiver(
                config.kafkaPayloadReceiver.topic,
                config.kafka,
                messageFilterService
            )
        }
    }
}

fun CoroutineScope.launchEbmsOutPayloadReceiver(
    config: Config,
    payloadMessageForwardingService: PayloadMessageForwardingService
) {
    if (config.kafkaEbmsOutPayloadReceiver.active) {
        launch(Dispatchers.IO) {
            startEbmsOutPayloadReceiver(
                config.kafkaEbmsOutPayloadReceiver.topic,
                config.kafka,
                payloadMessageForwardingService
            )
        }
    }
}

fun CoroutineScope.launchSignalReceiver(
    config: Config,
    messageFilterService: MessageFilterService
) {
    if (config.kafkaSignalReceiver.active) {
        launch(Dispatchers.IO) {
            startSignalReceiver(
                config.kafkaSignalReceiver.topic,
                config.kafka,
                messageFilterService = messageFilterService
            )
        }
    }
}

fun CoroutineScope.launchErrorRetryTask(
    config: Config,
    retryErrorsTimer: Timer,
    messageFilterService: MessageFilterService,
    failedMessageQueue: FailedMessageKafkaHandler,
    pauseRetryErrorsTimerFlag: PauseRetryErrorsTimerFlag
) {
    if (!config.kafkaErrorQueue.active) return

    retryErrorsTimer.scheduleAtFixedRate(delay = 5000L, period = TimeUnit.SECONDS.toMillis(config.errorRetryPolicy.processIntervalSeconds.toLong())) {
        launch(Dispatchers.IO) {
            log.info("=== RetryErrorsTask starting...")

            if (pauseRetryErrorsTimerFlag.paused) {
                log.info("Retry task is paused.")
                return@launch
            }

            failedMessageQueue.consumeRetryQueue(
                messageFilterService,
                config.errorRetryPolicy.maxMessagesToProcess
            )
        }
    }
}

fun Application.ebmsProviderModule(
    payloadRepository: PayloadRepository,
    messageFilterService: MessageFilterService,
    eventRegistrationService: EventRegistrationService,
    failedMessageQueue: FailedMessageKafkaHandler,
    pauseRetryErrorsTimerFlag: PauseRetryErrorsTimerFlag
) {
    val appMicrometerRegistry = PrometheusMeterRegistry(PrometheusConfig.DEFAULT)

    installMicrometerRegistry(appMicrometerRegistry)
    installContentNegotiation()
    installAuthentication()

    routing {
        registerRootEndpoint()
        registerHealthEndpoints()
        registerPrometheusEndpoint(appMicrometerRegistry)
        registerNavCheckStatus()
        if (!isProdEnv()) {
            simulateError(failedMessageQueue)
        }
        retryErrors(messageFilterService, failedMessageQueue)
        rerun(messageFilterService, failedMessageQueue)
        pauseRetries(pauseRetryErrorsTimerFlag)
        resumeRetries(pauseRetryErrorsTimerFlag)
        authenticate(AZURE_AD_AUTH) {
            getPayloads(payloadRepository, eventRegistrationService)
        }
    }
}

const val RETRY_LIMIT = "retryLimit"

fun Routing.retryErrors(
    messageFilterService: MessageFilterService,
    failedMessageQueue: FailedMessageKafkaHandler
): Route =
    get("/api/retry/{$RETRY_LIMIT}") {
        if (!config().kafkaErrorQueue.active) {
            call.respondText(status = HttpStatusCode.ServiceUnavailable, text = "Retry not active.")
            return@get
        }
        failedMessageQueue.consumeRetryQueue(
            messageFilterService,
            limit = (call.parameters[RETRY_LIMIT])?.toInt() ?: 10
        )
        call.respondText(
            status = HttpStatusCode.OK,
            text = "Retry processing started with limit ${call.parameters[RETRY_LIMIT] ?: "default"}"
        )
    }

fun Routing.rerun(
    messageFilterService: MessageFilterService,
    failedMessageQueue: FailedMessageKafkaHandler
): Route =
    get("/api/rerun/{$KAFKA_OFFSET}") {
        if (!config().kafkaErrorQueue.active) {
            call.respondText(status = HttpStatusCode.ServiceUnavailable, text = "Retry queue not active.")
            return@get
        }
        val offsetParam = (call.parameters[KAFKA_OFFSET])?.toLong()
        if (offsetParam == null) {
            call.respondText(status = HttpStatusCode.BadRequest, text = "Must specify offset of message to rerun.")
            return@get
        }
        failedMessageQueue.forceRetryFailedMessage(
            messageFilterService,
            offset = offsetParam
        )
        call.respondText(
            status = HttpStatusCode.OK,
            text = "Message with offset ${call.parameters[KAFKA_OFFSET]} has been re-run"
        )
    }

const val KAFKA_OFFSET = "offset"

fun Route.simulateError(
    failedMessageQueue: FailedMessageKafkaHandler
): Route =
    get("/api/forceretry/{$KAFKA_OFFSET}") {
        if (!config().kafkaErrorQueue.active) {
            call.respondText(status = HttpStatusCode.ServiceUnavailable, text = "Retry queue not active.")
            return@get
        }
        CoroutineScope(Dispatchers.IO).launch() {
            if (config().kafkaErrorQueue.active) {
                val record = getRecord(
                    config()
                        .kafkaPayloadReceiver.topic,
                    config().kafka
                        .copy(groupId = "ebms-provider-retry"),
                    (call.parameters[KAFKA_OFFSET])?.toLong() ?: 0
                )
                failedMessageQueue.sendToRetry(
                    record = record ?: throw Exception("No Record found. Offset: ${call.parameters[KAFKA_OFFSET]}"),
                    reason = "Simulated Error"
                )
                call.respondText(
                    status = HttpStatusCode.OK,
                    text = "Payload message with offset ${call.parameters[KAFKA_OFFSET]} has been added to retry queue"
                )
            }
        }
    }

fun Route.pauseRetries(
    pauseRetryErrorsTimerFlag: PauseRetryErrorsTimerFlag
): Route =
    get("/api/pauseretry") {
        CoroutineScope(Dispatchers.IO).launch() {
            pauseRetryErrorsTimerFlag.paused = true
        }
        log.info("Pausing retry task.")
        call.respond(StatusResponse("Error retries are PAUSED"))
    }

fun Route.resumeRetries(
    pauseRetryErrorsTimerFlag: PauseRetryErrorsTimerFlag
): Route =
    get("/api/resumeretry") {
        CoroutineScope(Dispatchers.IO).launch() {
            pauseRetryErrorsTimerFlag.paused = false
        }
        log.info("Resuming retry task.")
        call.respond(StatusResponse("Error retries are RESUMED"))
    }
