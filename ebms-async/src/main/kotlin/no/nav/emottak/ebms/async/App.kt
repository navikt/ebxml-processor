/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package no.nav.emottak.ebms.async

import arrow.continuations.SuspendApp
import arrow.continuations.ktor.server
import arrow.core.raise.result
import arrow.fx.coroutines.resourceScope
import io.ktor.server.application.Application
import io.ktor.server.auth.authenticate
import io.ktor.server.netty.Netty
import io.ktor.server.routing.routing
import io.ktor.utils.io.CancellationException
import io.micrometer.prometheusmetrics.PrometheusConfig
import io.micrometer.prometheusmetrics.PrometheusMeterRegistry
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.awaitCancellation
import kotlinx.coroutines.launch
import no.nav.emottak.ebms.AZURE_AD_AUTH
import no.nav.emottak.ebms.CpaRepoClient
import no.nav.emottak.ebms.EBMS_PAYLOAD_SCOPE
import no.nav.emottak.ebms.EBMS_SEND_IN_SCOPE
import no.nav.emottak.ebms.PayloadProcessingClient
import no.nav.emottak.ebms.SMTP_TRANSPORT_SCOPE
import no.nav.emottak.ebms.SendInClient
import no.nav.emottak.ebms.SmtpTransportClient
import no.nav.emottak.ebms.async.configuration.Config
import no.nav.emottak.ebms.async.configuration.config
import no.nav.emottak.ebms.async.kafka.consumer.startPayloadReceiver
import no.nav.emottak.ebms.async.kafka.consumer.startSignalReceiver
import no.nav.emottak.ebms.async.kafka.producer.EbmsMessageProducer
import no.nav.emottak.ebms.async.persistence.Database
import no.nav.emottak.ebms.async.persistence.ebmsDbConfig
import no.nav.emottak.ebms.async.persistence.ebmsMigrationConfig
import no.nav.emottak.ebms.async.persistence.repository.EbmsMessageDetailsRepository
import no.nav.emottak.ebms.async.persistence.repository.PayloadRepository
import no.nav.emottak.ebms.async.processing.PayloadMessageProcessor
import no.nav.emottak.ebms.async.processing.PayloadMessageResponder
import no.nav.emottak.ebms.async.processing.SignalProcessor
import no.nav.emottak.ebms.defaultHttpClient
import no.nav.emottak.ebms.processing.ProcessingService
import no.nav.emottak.ebms.registerHealthEndpoints
import no.nav.emottak.ebms.registerNavCheckStatus
import no.nav.emottak.ebms.registerPrometheusEndpoint
import no.nav.emottak.ebms.registerRootEndpoint
import no.nav.emottak.ebms.scopedAuthHttpClient
import no.nav.emottak.ebms.sendin.SendInService
import no.nav.emottak.ebms.validation.DokumentValidator
import org.slf4j.LoggerFactory

val log = LoggerFactory.getLogger("no.nav.emottak.ebms.async.App")

fun main() = SuspendApp {
    val database = Database(ebmsDbConfig.value)
    database.migrate(ebmsMigrationConfig.value)

    val config = config()
    val payloadRepository = PayloadRepository(database)
    val ebmsMessageDetailsRepository = EbmsMessageDetailsRepository(database)
    val processingClient = PayloadProcessingClient(scopedAuthHttpClient(EBMS_PAYLOAD_SCOPE))
    val processingService = ProcessingService(processingClient)
    val ebmsSignalProducer = EbmsMessageProducer(config.kafkaSignalProducer.topic, config.kafka)
    val ebmsPayloadProducer = EbmsMessageProducer(config.kafkaPayloadProducer.topic, config.kafka)

    val cpaClient = CpaRepoClient(defaultHttpClient())
    val dokumentValidator = DokumentValidator(cpaClient)

    val sendInClient = SendInClient(scopedAuthHttpClient(EBMS_SEND_IN_SCOPE))
    val sendInService = SendInService(sendInClient)

    val smtpTransportClient = SmtpTransportClient(scopedAuthHttpClient(SMTP_TRANSPORT_SCOPE))

    val payloadMessageResponder = PayloadMessageResponder(
        sendInService = sendInService,
        validator = dokumentValidator,
        processingService = processingService,
        payloadRepository = payloadRepository,
        ebmsMessageDetailsRepository = ebmsMessageDetailsRepository,
        ebmsPayloadProducer = ebmsPayloadProducer
    )

    result {
        resourceScope {
            launchSignalReceiver(
                config = config,
                dokumentValidator = dokumentValidator,
                ebmsMessageDetailsRepository = ebmsMessageDetailsRepository
            )
            launchPayloadReceiver(
                config = config,
                dokumentValidator = dokumentValidator,
                processingService = processingService,
                ebmsSignalProducer = ebmsSignalProducer,
                smtpTransportClient = smtpTransportClient,
                payloadMessageResponder = payloadMessageResponder,
                ebmsMessageDetailsRepository = ebmsMessageDetailsRepository
            )

            server(
                Netty,
                port = 8080,
                module = {
                    ebmsProviderModule(
                        payloadRepository = payloadRepository
                    )
                }
            ).also { it.engineConfig.maxChunkSize = 100000 }

            awaitCancellation()
        }
    }
        .onFailure { error ->
            when (error) {
                is CancellationException -> {} // expected behaviour - normal shutdown
                else -> log.error("Unexpected shutdown initiated", error)
            }
        }
}

private fun CoroutineScope.launchPayloadReceiver(
    config: Config,
    dokumentValidator: DokumentValidator,
    processingService: ProcessingService,
    ebmsSignalProducer: EbmsMessageProducer,
    smtpTransportClient: SmtpTransportClient,
    payloadMessageResponder: PayloadMessageResponder,
    ebmsMessageDetailsRepository: EbmsMessageDetailsRepository
) {
    if (config.kafkaPayloadReceiver.active) {
        launch(Dispatchers.IO) {
            val payloadMessageProcessor = PayloadMessageProcessor(
                validator = dokumentValidator,
                processingService = processingService,
                ebmsSignalProducer = ebmsSignalProducer,
                smtpTransportClient = smtpTransportClient,
                ebmsMessageDetailsRepository = ebmsMessageDetailsRepository,
                payloadMessageResponder = payloadMessageResponder
            )
            startPayloadReceiver(config.kafkaPayloadReceiver.topic, config.kafka, payloadMessageProcessor)
        }
    }
}

private fun CoroutineScope.launchSignalReceiver(
    config: Config,
    dokumentValidator: DokumentValidator,
    ebmsMessageDetailsRepository: EbmsMessageDetailsRepository
) {
    if (config.kafkaSignalReceiver.active) {
        launch(Dispatchers.IO) {
            val signalProcessor = SignalProcessor(
                ebmsMessageDetailsRepository,
                dokumentValidator
            )
            startSignalReceiver(config.kafkaSignalReceiver.topic, config.kafka, signalProcessor)
        }
    }
}

fun Application.ebmsProviderModule(
    payloadRepository: PayloadRepository
) {
    val appMicrometerRegistry = PrometheusMeterRegistry(PrometheusConfig.DEFAULT)

    log.info("Logging test: 11cc63e2-97e9-4f24-9127-a12345678901")
    log.info("Logging test: 11cc63e2-97e9-4f24-9127-123456789012")
    log.info("Logging test: 11cc63e2-97e9-4f24-9127--12345678901")
    log.info("Logging test: 11cc63e2-97e9-4f24-9127-ab12345678901")

    installMicrometerRegistry(appMicrometerRegistry)
    installContentNegotiation()
    installAuthentication()

    routing {
        registerRootEndpoint()
        registerHealthEndpoints()
        registerPrometheusEndpoint(appMicrometerRegistry)
        registerNavCheckStatus()

        authenticate(AZURE_AD_AUTH) {
            getPayloads(payloadRepository)
        }
    }
}
