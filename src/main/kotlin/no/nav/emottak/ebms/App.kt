/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package no.nav.emottak.ebms

import io.ktor.http.*
import io.ktor.http.content.*
import io.ktor.serialization.kotlinx.json.json
import io.ktor.server.application.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*
import io.ktor.server.plugins.contentnegotiation.ContentNegotiation
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import no.nav.emottak.ebms.model.*
import no.nav.emottak.ebms.validation.DokumentValidator
import no.nav.emottak.ebms.validation.MimeValidationException
import no.nav.emottak.ebms.validation.asParseAsSoapFault
import no.nav.emottak.ebms.validation.validateMime
import no.nav.emottak.ebms.validation.validateMimeAttachment
import no.nav.emottak.ebms.validation.validateMimeSoapEnvelope
import no.nav.emottak.ebms.xml.getDocumentBuilder
import no.nav.emottak.util.marker
import java.io.ByteArrayInputStream


fun main() {
    //val database = Database(mapHikariConfig(DatabaseConfig()))
    //database.migrate()
    embeddedServer(Netty, port = 8080, module = Application::myApplicationModule).start(wait = true)
}

fun PartData.payload() : ByteArray {
    return when(this) {
        is PartData.FormItem -> java.util.Base64.getMimeDecoder().decode(this.value)
        is PartData.FileItem -> {
            val bytes = this.streamProvider.invoke().readAllBytes()
            java.util.Base64.getMimeDecoder().decode(bytes)
        }
        else -> byteArrayOf()
    }
}


fun Application.myApplicationModule() {
    install(ContentNegotiation) {
        json()
    }

    routing {
        get("/") {
            call.application.environment.log.info("TESTEST")
            call.respondText("Hello, world!")
        }
        post("/ebms") {
            // KRAV 5.5.2.1 validate MIME

            try {
                call.request.validateMime()
            } catch (it: MimeValidationException) {
                call.respond(HttpStatusCode.InternalServerError, it.asParseAsSoapFault())
                return@post

            }

            val ebMSDocument: EbMSDocument
            try {
                ebMSDocument = call.receiveEbmsDokument()
            } catch (ex: MimeValidationException) {
                call.respond(HttpStatusCode.InternalServerError, ex.asParseAsSoapFault())
                return@post
            }
            try {
                DokumentValidator().validate(ebMSDocument)
            }catch(ex:Exception) {
                call.respond(HttpStatusCode.InternalServerError,"Validation feilet")
            }

            val message = ebMSDocument.buildEbmMessage()
            try {
                when (message) {
                    is EbmsAcknowledgment ->  message.process()
                    is EbMSMessageError -> message.process()
                    is EbMSPayloadMessage -> {
                        when (val response = message.process()) {
                            is EbmsAcknowledgment -> response.toEbmsDokument().sendResponse(response.messageHeader)
                            is EbMSMessageError -> response.toEbmsDokument().sendErrorResponse(response.messageHeader)
                        }
                    }
                }
            } catch (e: Exception) {
                call.application.environment.log.error(message.messageHeader.marker(), "Feil ved prosessering av melding", e)
                call.respond(HttpStatusCode.InternalServerError, "Feil ved prosessering av melding")
                return@post
            }

            //call payload processor
            println(ebMSDocument)

            call.respondText("Hello")
        }
    }

}

@Throws(MimeValidationException::class)
suspend fun ApplicationCall.receiveEbmsDokument() : EbMSDocument {

    return when (val contentType = this.request.contentType().withoutParameters()) {
        ContentType.parse("multipart/related") -> {
            val allParts = this.receiveMultipart().readAllParts()
                val dokument = allParts.find {
                    it.contentType?.withoutParameters() == ContentType.parse("text/xml") && it.contentDisposition == null
                }.also { it?.validateMimeSoapEnvelope() ?: throw MimeValidationException("Unable to find soap envelope multipart") }!!.payload()
                val attachments =
                    allParts.filter { it.contentDisposition?.disposition == ContentDisposition.Attachment.disposition }
                attachments.forEach {
                    it.validateMimeAttachment()
                }
                EbMSDocument(
                    "",
                    getDocumentBuilder().parse(ByteArrayInputStream(dokument)),
                    attachments.map {
                        EbMSAttachment(
                            it.payload(),
                            it.contentType!!.contentType,
                            it.headers["Content-Id"]!!
                        )
                    })

        }
        ContentType.parse("text/xml") -> {
            val dokument = this.receiveStream().readAllBytes()
            EbMSDocument(
                "",
                getDocumentBuilder().parse(ByteArrayInputStream(dokument)),
                emptyList()
            )
        }
        else -> {
            throw MimeValidationException("Ukjent request body med Content-Type $contentType")
            //call.respond(HttpStatusCode.BadRequest, "Ukjent request body med Content-Type $contentType")
            //return@post
        }
    }
}
